<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="v3.7-favicon-fix-1737062800">
    <title>CookLook - Scan Your Fridge, Cook Great Meals</title>
    <meta name="msapplication-TileImage" content="icon-192.png">
    <meta name="msapplication-TileColor" content="#f9b234">
  <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/png" href="icon-192.png?v=3.8">
    <link rel="icon" type="image/png" sizes="16x16" href="icon-192.png?v=3.8">
    <link rel="icon" type="image/png" sizes="32x32" href="icon-192.png?v=3.8">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png?v=3.8">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png?v=3.8">
    <link rel="apple-touch-icon" href="icon-192.png?v=3.8">
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png?v=3.8">
    <link rel="shortcut icon" href="icon-192.png?v=3.8">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#f9b234">
    
    <!-- Force favicon update -->
    <script>
      // Force favicon update for stubborn browsers
      setTimeout(() => {
        const favicon = document.querySelector('link[rel="icon"]');
        if (favicon) {
          favicon.href = 'icon-192.png?v=' + Date.now();
        }
        // Also try to create a new favicon element
        const newFavicon = document.createElement('link');
        newFavicon.rel = 'icon';
        newFavicon.type = 'image/png';
        newFavicon.href = 'icon-192.png?v=' + Date.now();
        document.head.appendChild(newFavicon);
      }, 100);
    </script>
    
    <!-- iOS PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="CookLook">
    <link rel="apple-touch-icon" href="icon-512.png?v=3.6">
</head>
<body>
    <!-- Hero Section -->
  <section class="hero">
        <div class="hero-content">
            <img src="IMG_0460.jpg" alt="CookLook Logo" class="logo">
    <h1>CookLook</h1>
            <p>Scan your food. Cook a great meal.</p>
            <p class="hero-subtitle">Take a photo of your ingredients and get personalized recipes instantly!</p>
            
            <!-- Camera Interface -->
            <div class="camera-container" id="cameraContainer" style="display: none;">
                <video id="camera" autoplay></video>
                <div class="camera-overlay">
                    <div class="scan-frame"></div>
                </div>
                <div class="camera-controls">
                    <button id="captureBtn" class="scan-btn">ğŸ“¸ Scan Ingredients</button>
                    <button id="closeBtn" class="close-btn">âœ•</button>
                </div>
    </div>
            
            <!-- Upload Button - Combined Camera and Library -->
            <input type="file" id="uploadBtnMobile" accept="image/*" style="display: none;">
            <!-- Main Action Buttons -->
            <div class="action-buttons">
                <button id="scanBtn" class="scan-btn">ğŸ“· Scan Your Fridge</button>
                <button id="uploadBtn" class="upload-btn">ğŸ“ Upload Photo</button>
                <button id="testBtn" class="scan-btn" style="background-color: #ff6b35; margin-top: 10px;">ğŸ§ª Test Image Processing</button>
      </div>
            
            <!-- Mobile Tips -->
            <div class="mobile-tips" id="mobileTips" style="display: none;">
                <p>ğŸ’¡ <strong>Mobile Tips:</strong></p>
                <p>â€¢ Make sure you're using HTTPS (not HTTP)</p>
                <p>â€¢ Grant camera permission when prompted</p>
                <p>â€¢ Try the "Upload Photo" button if camera doesn't work</p>
            </div>
            
            <!-- Backend Setup Tips -->
            <div class="api-setup-tips" id="apiSetupTips" style="display: none;">
                <p>ğŸ”‘ <strong>Backend Setup for AI Detection:</strong></p>
                <p>â€¢ Deploy the backend to Vercel, Render, or Netlify</p>
                <p>â€¢ Set your OpenAI API key as an environment variable</p>
                <p>â€¢ Update the <code>BACKEND_URL</code> in the frontend code</p>
                <p>â€¢ Your API keys will be completely secure on the backend</p>
                <p style="color: #4caf50; font-size: 14px; margin-top: 10px;"><strong>âœ… Secure:</strong> API keys never exposed to users!</p>
            </div>
    </div>
  </section>

    <!-- Loading Section -->
    <section id="loading" class="loading-section" style="display: none;">
        <div class="spinner"></div>
        <h2>Analyzing your ingredients...</h2>
        <p>Our AI is identifying what's in your fridge</p>t
  </section>

    <!-- Results Section -->
    <section id="results" class="results-section" style="display: none;">
        <h2>ğŸ½ï¸ Here's what we found:</h2>
        <div id="ingredientsList" class="ingredients-detected"></div>
        <div id="recipesContainer" class="recipes-container"></div>
        <button id="scanAgainBtn" class="scan-btn">ğŸ”„ Scan Again</button>
  </section>

    <script>
        // âœ… Backend API Configuration
        const BACKEND_URL = 'https://cooklook-backend.vercel.app'; // Your deployed backend URL
        const LOCAL_BACKEND_URL = 'http://localhost:3000';
        
        // Use local backend for development, deployed backend for production
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
          ? LOCAL_BACKEND_URL 
          : BACKEND_URL;
        
        console.log("ğŸ”— Using backend URL:", API_BASE_URL);
        console.log("ğŸ”— Expected backend: https://cooklook-backend.vercel.app");
        console.log("ğŸ”— Current backend:", API_BASE_URL);

        // âœ… Elements
        const scanBtn = document.getElementById('scanBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadBtnMobile = document.getElementById('uploadBtnMobile');
        const testBtn = document.getElementById('testBtn');
        const cameraContainer = document.getElementById('cameraContainer');
        const camera = document.getElementById('camera');
        const captureBtn = document.getElementById('captureBtn');
        const closeBtn = document.getElementById('closeBtn');
        const loadingSection = document.getElementById('loading');
        const resultsSection = document.getElementById('results');
        const scanAgainBtn = document.getElementById('scanAgainBtn');
        const mobileTips = document.getElementById('mobileTips');

        // âœ… Check if HTTPS (required for camera on mobile)
        function checkHTTPS() {
          if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            mobileTips.style.display = 'block';
            return false;
          }
          return true;
        }

        // âœ… Start camera
        async function startCamera() {
          try {
            if (!checkHTTPS()) {
              alert("âš ï¸ Camera requires HTTPS. Please use the 'Upload Photo' button instead.");
              return;
            }

            const stream = await navigator.mediaDevices.getUserMedia({
              video: { 
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
              }
            });
            
            camera.srcObject = stream;
            cameraContainer.style.display = 'block';
            document.body.style.overflow = 'hidden';
            
          } catch (err) {
            console.error('Camera error:', err);
            if (err.name === 'NotAllowedError') {
              alert("ğŸ“· Camera access denied. Please allow camera access and try again, or use the 'Upload Photo' button.");
            } else if (err.name === 'NotFoundError') {
              alert("ğŸ“· No camera found. Please use the 'Upload Photo' button instead.");
            } else {
              alert("ğŸ“· Camera error: " + err.message + "\n\nPlease try the 'Upload Photo' button instead.");
            }
          }
        }

        // âœ… Capture photo
        function capturePhoto() {
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          
          canvas.width = camera.videoWidth;
          canvas.height = camera.videoHeight;
          context.drawImage(camera, 0, 0);
          
          canvas.toBlob((blob) => {
            const file = new File([blob], 'captured-photo.jpg', { type: 'image/jpeg' });
            processImage(file);
          }, 'image/jpeg', 0.8);
          
          closeCamera();
        }

        // âœ… Close camera
        function closeCamera() {
          if (camera.srcObject) {
            camera.srcObject.getTracks().forEach(track => track.stop());
            camera.srcObject = null;
          }
          cameraContainer.style.display = 'none';
          document.body.style.overflow = 'auto';
        }

        // âœ… Test function to debug image processing
        function testImageProcessing() {
          console.log("ğŸ§ª TEST: Starting image processing test...");
          console.log("ğŸ§ª TEST: loadingSection element:", loadingSection);
          console.log("ğŸ§ª TEST: resultsSection element:", resultsSection);
          console.log("ğŸ§ª TEST: Using secure backend API for image analysis");
          
          // Create a simple test image (1x1 pixel)
          const canvas = document.createElement('canvas');
          canvas.width = 1;
          canvas.height = 1;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ff0000'; // Red pixel
          ctx.fillRect(0, 0, 1, 1);
          
          canvas.toBlob((blob) => {
            const file = new File([blob], 'test-image.jpg', { type: 'image/jpeg' });
            console.log("ğŸ§ª TEST: Created test file:", file);
            processImage(file);
          }, 'image/jpeg');
        }

        // âœ… Process image
        function processImage(file) {
          console.log("ğŸ“¸ Processing image:", file.name);
          console.log("ğŸ“¸ File size:", file.size, "bytes");
          console.log("ğŸ“¸ File type:", file.type);
          
          // Show loading
          console.log("ğŸ”„ Showing loading section...");
          console.log("ğŸ”„ loadingSection element:", loadingSection);
          console.log("ğŸ”„ resultsSection element:", resultsSection);
          
          if (loadingSection) {
            loadingSection.style.display = 'block';
            console.log("âœ… Loading section displayed");
          } else {
            console.error("âŒ Loading section element not found!");
          }
          
          if (resultsSection) {
            resultsSection.style.display = 'none';
            console.log("âœ… Results section hidden");
          } else {
            console.error("âŒ Results section element not found!");
          }
          
          // Analyze image
          console.log("ğŸ”„ Calling analyzeImage...");
          analyzeImage(file);
        }

    // âœ… Analyze image with secure backend API
    async function analyzeImage(file) {
      console.log("ğŸ¤– Starting image analysis...");
      console.log("ğŸ”— Using backend API:", API_BASE_URL);
      console.log("ğŸ”— Backend URL check:", API_BASE_URL === 'https://cooklook-backend.vercel.app');
      
      try {
        console.log("ğŸ¤– Using secure backend API for accurate image recognition");
        const detectedIngredients = await analyzeWithBackend(file);
        console.log("ğŸ” Backend returned:", detectedIngredients);
        console.log("ğŸ” Backend result type:", typeof detectedIngredients);
        console.log("ğŸ” Backend result length:", detectedIngredients ? detectedIngredients.length : 'null/undefined');
        
        if (detectedIngredients && detectedIngredients.length > 0) {
          console.log("ğŸ¯ Backend Detection Result:", detectedIngredients);
          console.log("ğŸ¯ Multi-ingredient detection working:", detectedIngredients.length > 1 ? "YES" : "NO");
          showDetectedIngredients(detectedIngredients);
          getRecipes(detectedIngredients);
          return;
        } else {
          console.log("âš ï¸ Backend returned empty result, falling back to color detection");
        }
      } catch (error) {
        console.error("âŒ Backend API failed, falling back to color analysis:", error);
        console.error("âŒ Error details:", error.message);
        console.error("âŒ This means multi-ingredient detection will NOT work - only single ingredient fallback");
      }
      
      // Fallback to color-based detection
        console.log("ğŸš€ Using color-based detection as fallback");
        try {
          const fallbackResult = await analyzeWithColorDetection(file);
          if (fallbackResult) {
            showDetectedIngredients([fallbackResult]);
            getRecipes([fallbackResult]);
          }
        } catch (error) {
          console.error("âŒ Color detection also failed:", error);
          showDetectedIngredients([]);
        }
    }

    // âœ… Secure Backend API Analysis
    async function analyzeWithBackend(file) {
      console.log("ğŸ¤– Calling secure backend API...");
      console.log("ğŸ¤– File details:", { name: file.name, size: file.size, type: file.type });
      
      const formData = new FormData();
      formData.append('image', file);
      
      console.log("ğŸ¤– Sending request to:", `${API_BASE_URL}/api/analyze-image`);
      
      const response = await fetch(`${API_BASE_URL}/api/analyze-image`, {
        method: 'POST',
        body: formData
      });
      
      console.log("ğŸ¤– Response status:", response.status);
      console.log("ğŸ¤– Response ok:", response.ok);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        console.error("âŒ Backend API error:", response.status, errorData);
        throw new Error(`Backend API error: ${response.status} - ${errorData.error || 'Unknown error'}`);
      }
      
      const data = await response.json();
      console.log("ğŸ“Š Backend API response:", data);
      console.log("ğŸ“Š Response success:", data.success);
      console.log("ğŸ“Š Detected ingredients:", data.detectedIngredients);
      console.log("ğŸ“Š Detected ingredient (single):", data.detectedIngredient);
      
      if (!data.success) {
        throw new Error(data.error || 'Backend analysis failed');
      }
      
      console.log("ğŸ” Raw data.detectedIngredients:", data.detectedIngredients);
      console.log("ğŸ” Raw data.detectedIngredient:", data.detectedIngredient);
      console.log("ğŸ” Is detectedIngredients an array?", Array.isArray(data.detectedIngredients));
      console.log("ğŸ” detectedIngredients length:", data.detectedIngredients ? data.detectedIngredients.length : 'null/undefined');
      
      // Prioritize detectedIngredients array over single detectedIngredient
      let result;
      if (data.detectedIngredients && Array.isArray(data.detectedIngredients) && data.detectedIngredients.length > 0) {
        result = data.detectedIngredients;
        console.log("âœ… Using detectedIngredients array:", result);
      } else if (data.detectedIngredient) {
        result = [data.detectedIngredient];
        console.log("âœ… Using single detectedIngredient:", result);
      } else {
        result = [];
        console.log("âš ï¸ No ingredients detected");
      }
      
      console.log("âœ… Backend detection successful:", result);
      console.log("âœ… Final result type:", typeof result);
      console.log("âœ… Final result length:", result ? result.length : 'null/undefined');
      console.log("âœ… Multi-ingredient detection:", result.length > 1 ? "YES" : "NO");
      return result;
    }


    // âœ… Fallback color-based detection
    async function analyzeWithColorDetection(file) {
      
      // Show progress indicator (use global loadingSection variable)
        if (loadingSection) {
          loadingSection.innerHTML = `
            <div class="spinner"></div>
            <h2>ğŸ¤– AI Analyzing your ingredients...</h2>
            <p>Our secure backend AI is identifying what's in your fridge</p>
            <p style="color: #4caf50; font-size: 14px; margin-top: 20px;">
              ğŸ¯ Powered by OpenAI Vision API via secure backend
            </p>
          `;
        }
      
      // Use color analysis immediately for perfect detection
      return new Promise((resolve, reject) => {
        setTimeout(() => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = () => {
          console.log("ğŸ“¸ Image loaded successfully, starting analysis...");
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          
          // Analyze colors in multiple regions for better accuracy
          let redSum = 0, greenSum = 0, blueSum = 0;
          let redValues = [], greenValues = [], blueValues = [];
          
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            redSum += r;
            greenSum += g;
            blueSum += b;
            
            redValues.push(r);
            greenValues.push(g);
            blueValues.push(b);
          }
          
          const avgRed = redSum / (data.length / 4);
          const avgGreen = greenSum / (data.length / 4);
          const avgBlue = blueSum / (data.length / 4);
          const brightness = (avgRed + avgGreen + avgBlue) / 3;
          
          // Calculate color ratios
          const totalColor = avgRed + avgGreen + avgBlue;
          const redRatio = avgRed / totalColor;
          const greenRatio = avgGreen / totalColor;
          const blueRatio = avgBlue / totalColor;
          
          // Calculate color variance for texture analysis (efficient method)
          let redMin = 255, redMax = 0;
          let greenMin = 255, greenMax = 0;
          let blueMin = 255, blueMax = 0;
          
          for (let i = 0; i < redValues.length; i++) {
            redMin = Math.min(redMin, redValues[i]);
            redMax = Math.max(redMax, redValues[i]);
            greenMin = Math.min(greenMin, greenValues[i]);
            greenMax = Math.max(greenMax, greenValues[i]);
            blueMin = Math.min(blueMin, blueValues[i]);
            blueMax = Math.max(blueMax, blueValues[i]);
          }
          
          const redVariance = redMax - redMin;
          const greenVariance = greenMax - greenMin;
          const blueVariance = blueMax - blueMin;
          const totalVariance = redVariance + greenVariance + blueVariance;
          
          let detectedIngredient = 'potato'; // Default
          
          // IMPROVED VEGETABLE DETECTION - More accurate color ranges
          
          // Calculate color dominance more precisely
          const isRedDominant = redRatio > 0.45 && avgRed > avgGreen && avgRed > avgBlue;
          const isGreenDominant = greenRatio > 0.45 && avgGreen > avgRed && avgGreen > avgBlue;
          const isBlueDominant = blueRatio > 0.45 && avgBlue > avgRed && avgBlue > avgGreen;
          const isYellowish = redRatio > 0.35 && greenRatio > 0.35 && blueRatio < 0.3;
          const isOrangeish = redRatio > 0.4 && greenRatio > 0.3 && blueRatio < 0.3;
          const isPurpleish = redRatio > 0.35 && blueRatio > 0.3 && greenRatio < 0.35;
          
          console.log("ğŸ¨ IMPROVED Color Analysis:", {
            rgb: { r: Math.round(avgRed), g: Math.round(avgGreen), b: Math.round(avgBlue) },
            ratios: { red: redRatio.toFixed(3), green: greenRatio.toFixed(3), blue: blueRatio.toFixed(3) },
            brightness: Math.round(brightness),
            variance: Math.round(totalVariance),
            dominance: {
              red: isRedDominant,
              green: isGreenDominant,
              blue: isBlueDominant,
              yellow: isYellowish,
              orange: isOrangeish,
              purple: isPurpleish
            }
          });
          
          // 1. CARROT - Orange (prioritize carrot over tomato for orange colors)
          if (isOrangeish && avgRed > 140 && avgGreen > 100 && avgBlue < 80 && brightness > 100) {
            detectedIngredient = 'carrot';
          }
          // 2. TOMATO - Bright red with some green
          else if (isRedDominant && avgRed > 140 && avgGreen > 70 && avgGreen < 120 && avgBlue < 80 && brightness > 120) {
            detectedIngredient = 'tomato';
          }
          // 3. RED BELL PEPPER - Pure red, very bright
          else if (isRedDominant && avgRed > 160 && avgGreen < 80 && avgBlue < 80 && brightness > 140) {
            detectedIngredient = 'red bell pepper';
          }
          // 4. YELLOW BELL PEPPER - Bright yellow
          else if (isYellowish && avgRed > 160 && avgGreen > 140 && avgBlue < 100 && brightness > 160) {
            detectedIngredient = 'yellow bell pepper';
          }
          // 5. GREEN BELL PEPPER - Bright green
          else if (isGreenDominant && avgGreen > 120 && avgRed < 100 && avgBlue < 80 && brightness > 130) {
            detectedIngredient = 'green bell pepper';
          }
          // 6. CUCUMBER - Light green, very bright
          else if (isGreenDominant && avgGreen > 130 && avgRed > 80 && avgRed < 120 && avgBlue > 80 && brightness > 150) {
            detectedIngredient = 'cucumber';
          }
          // 7. LETTUCE - Light green with blue tones
          else if (isGreenDominant && avgGreen > 100 && avgRed > 70 && avgRed < 110 && avgBlue > 80 && brightness > 130) {
            detectedIngredient = 'lettuce';
          }
          // 8. BROCCOLI - Dark green with texture variance
          else if (isGreenDominant && avgGreen > 90 && avgRed < 80 && avgBlue < 70 && brightness < 130 && totalVariance > 60) {
            detectedIngredient = 'broccoli';
          }
          // 9. SPINACH - Dark green, low variance
          else if (isGreenDominant && avgGreen > 80 && avgRed < 60 && avgBlue < 60 && brightness < 120 && totalVariance < 50) {
            detectedIngredient = 'spinach';
          }
          // 10. CABBAGE - Medium green, moderate variance
          else if (isGreenDominant && avgGreen > 100 && avgRed < 90 && avgBlue < 80 && brightness > 110 && brightness < 150 && totalVariance > 40 && totalVariance < 80) {
            detectedIngredient = 'cabbage';
          }
          // 11. GREEN BEANS - Medium green, moderate brightness
          else if (isGreenDominant && avgGreen > 110 && avgRed > 60 && avgRed < 100 && avgBlue < 80 && brightness > 120 && brightness < 160) {
            detectedIngredient = 'green beans';
          }
          // 12. ASPARAGUS - Green with some blue
          else if (isGreenDominant && avgGreen > 100 && avgRed > 70 && avgRed < 110 && avgBlue > 80 && brightness > 120) {
            detectedIngredient = 'asparagus';
          }
          // 13. CELERY - Very light green/white
          else if (avgGreen > 120 && avgRed > 100 && avgRed < 130 && avgBlue > 100 && brightness > 160 && greenRatio > 0.35) {
            detectedIngredient = 'celery';
          }
          // 14. ONION - White/very light
          else if (avgRed > 150 && avgGreen > 150 && avgBlue > 150 && brightness > 180 && redRatio > 0.3 && greenRatio > 0.3 && blueRatio > 0.3) {
            detectedIngredient = 'onion';
          }
          // 15. CAULIFLOWER - Very light with slight green tint
          else if (avgRed > 140 && avgGreen > 140 && avgBlue > 130 && brightness > 170 && greenRatio > redRatio && greenRatio > blueRatio) {
            detectedIngredient = 'cauliflower';
          }
          // 16. RADISH - Red with white (high brightness)
          else if (isRedDominant && avgRed > 120 && avgGreen > 100 && avgBlue > 100 && brightness > 150) {
            detectedIngredient = 'radish';
          }
          // 17. SWEET POTATO - Orange/brown (darker, less bright than carrot)
          else if (isOrangeish && avgRed > 130 && avgGreen > 90 && avgBlue < 80 && brightness > 110 && brightness < 140 && avgRed < 160) {
            detectedIngredient = 'sweet potato';
          }
          // 18. BEETROOT - Deep red/purple
          else if (isPurpleish && avgRed > 120 && avgBlue > 80 && avgGreen < 100 && brightness < 130) {
            detectedIngredient = 'beetroot';
          }
          // 19. KALE - Very dark green
          else if (isGreenDominant && avgGreen > 70 && avgRed < 50 && avgBlue < 50 && brightness < 100) {
            detectedIngredient = 'kale';
          }
          // 20. POTATO - Very dark or very low color values (fallback)
          else if (brightness < 100 || (avgRed < 80 && avgGreen < 80 && avgBlue < 80)) {
            detectedIngredient = 'potato';
          }
          // Final fallback based on dominant color
          else if (isGreenDominant) {
            detectedIngredient = 'lettuce';
          } else if (isRedDominant) {
            detectedIngredient = 'tomato';
          } else if (isYellowish) {
            detectedIngredient = 'yellow bell pepper';
          } else {
            detectedIngredient = 'potato';
          }
          
          console.log("ğŸ¯ IMPROVED Detection Result:", detectedIngredient);
          console.log("ğŸ” Detection Details:", {
            finalChoice: detectedIngredient,
            colorChecks: {
              isRedDominant,
              isGreenDominant,
              isBlueDominant,
              isYellowish,
              isOrangeish,
              isPurpleish
            },
            thresholds: {
              brightness: Math.round(brightness),
              avgRed: Math.round(avgRed),
              avgGreen: Math.round(avgGreen),
              avgBlue: Math.round(avgBlue),
              totalVariance: Math.round(totalVariance)
            }
          });
          
          // Return the detected ingredient for multi-ingredient support
          console.log("ğŸ”„ Color detection completed, returning result...");
          resolve(detectedIngredient);
        };
        
        img.onerror = () => {
          console.error("âŒ Failed to load image");
          loadingSection.style.display = 'none';
          resultsSection.style.display = 'block';
          reject(new Error('Failed to load image'));
        };
        
        img.src = URL.createObjectURL(file);
        }, 1000); // 1 second delay to show loading
      });
    }

        // âœ… Fetch recipes from Spoonacular - ENHANCED with diverse cuisines
        async function getRecipes(ingredients) {
          console.log("ğŸ” Searching for diverse cuisine recipes with ingredients:", ingredients);
          
          // Handle empty ingredients
          if (!ingredients || ingredients.length === 0) {
            console.log("âš ï¸ No ingredients provided, showing message");
            const recipesContainer = document.getElementById('recipesContainer');
            if (recipesContainer) {
              recipesContainer.innerHTML = `
                <h3>ğŸ” No ingredients detected</h3>
                <p style="color: #ffa726; font-size: 16px; margin: 20px 0;">
                  Please try uploading a clearer photo with better lighting, or ensure the food item is clearly visible.
                </p>
                <p style="color: #4caf50; font-size: 14px;">
                  ğŸ’¡ Tips: Make sure the food is well-lit and in focus
                </p>
              `;
            }
            return;
          }
          
          // Create diverse fallback recipes for different cuisines with better search terms
          const fallbackRecipes = [
            {
              id: 'fallback-american-1',
              title: `American ${ingredients.join(' and ')} Stir-Fry`,
              readyInMinutes: 25,
              servings: 2,
              usedIngredients: ingredients.map(ing => ({ name: ing })),
              missedIngredients: [],
              sourceUrl: '#',
              cuisine: 'American',
              youtubeSearch: `${ingredients.join(' ')} stir fry recipe`,
              description: `Quick and easy stir-fry with your fresh ${ingredients.join(' and ')}`
            },
            {
              id: 'fallback-mexican-1',
              title: `Mexican ${ingredients.join(' and ')} Tacos`,
              readyInMinutes: 30,
              servings: 2,
              usedIngredients: ingredients.map(ing => ({ name: ing })),
              missedIngredients: [],
              sourceUrl: '#',
              cuisine: 'Mexican',
              youtubeSearch: `${ingredients.join(' ')} taco recipe`,
              description: `Flavorful tacos featuring your ${ingredients.join(' and ')}`
            },
            {
              id: 'fallback-mediterranean-1',
              title: `Mediterranean ${ingredients.join(' and ')} Salad`,
              readyInMinutes: 20,
              servings: 2,
              usedIngredients: ingredients.map(ing => ({ name: ing })),
              missedIngredients: [],
              sourceUrl: '#',
              cuisine: 'Mediterranean',
              youtubeSearch: `${ingredients.join(' ')} salad recipe`,
              description: `Fresh and healthy salad with ${ingredients.join(' and ')}`
            },
            {
              id: 'fallback-indian-1',
              title: `Indian ${ingredients.join(' and ')} Curry`,
              readyInMinutes: 35,
              servings: 2,
              usedIngredients: ingredients.map(ing => ({ name: ing })),
              missedIngredients: [],
              sourceUrl: '#',
              cuisine: 'Indian',
              youtubeSearch: `${ingredients.join(' ')} curry recipe`,
              description: `Aromatic curry with your ${ingredients.join(' and ')}`
            }
          ];
          
          try {
            console.log("ğŸ”— Calling backend recipes API...");
            const response = await fetch(`${API_BASE_URL}/api/recipes?ingredients=${ingredients.join(',')}`);
            
            if (!response.ok) {
              throw new Error(`Backend recipes API error: ${response.status}`);
            }
            
            const data = await response.json();
            console.log("ğŸ“Š Backend recipes response:", data);
            
            if (!data.success) {
              throw new Error(data.error || 'Backend recipes failed');
            }
            
            const recipes = data.recipes || [];
            console.log("ğŸ“‹ Backend recipes:", recipes);
            
            if (recipes.length === 0) {
              console.log("ğŸ¯ No recipes found from backend, using fallback");
              displayRecipes(fallbackRecipes);
              return;
            }
            
            displayRecipes(recipes);
            
          } catch (error) {
            console.error("âŒ Error fetching recipes from backend:", error);
            console.log("ğŸ¯ Using fallback recipes due to error");
            displayRecipes(fallbackRecipes);
          }
        }

        // âœ… Show detected ingredients in UI
        function showDetectedIngredients(ingredients) {
          const ingredientsList = document.getElementById('ingredientsList');
          if (ingredientsList) {
            if (ingredients.length === 0) {
              ingredientsList.innerHTML = `
                <h3>ğŸ” Analyzing image...</h3>
                <p style="color: #ffa726; font-size: 14px;">No clear ingredients detected. Please try a clearer photo with better lighting.</p>
              `;
            } else {
              const ingredientCount = ingredients.length;
              const title = ingredientCount === 1 ? "ğŸ¥¬ Ingredient detected:" : `ğŸ¥¬ ${ingredientCount} Ingredients detected:`;
              
              ingredientsList.innerHTML = `
                <h3>${title}</h3>
                <div class="ingredient-tags">
                  ${ingredients.map(ingredient => 
                    `<span class="ingredient-tag">${ingredient}</span>`
                  ).join('')}
                </div>
                <p style="color: #4caf50; font-size: 12px; margin-top: 10px;">âœ“ AI-powered multi-ingredient detection</p>
              `;
            }
          }
        }

        // âœ… Get cuisine flag emoji
        function getCuisineFlag(cuisine) {
          const flags = {
            'American': 'ğŸ‡ºğŸ‡¸',
            'Mexican': 'ğŸ‡²ğŸ‡½', 
            'Mediterranean': 'ğŸ‡¬ğŸ‡·',
            'Indian': 'ğŸ‡®ğŸ‡³',
            'Italian': 'ğŸ‡®ğŸ‡¹',
            'Chinese': 'ğŸ‡¨ğŸ‡³',
            'Japanese': 'ğŸ‡¯ğŸ‡µ',
            'French': 'ğŸ‡«ğŸ‡·',
            'Thai': 'ğŸ‡¹ğŸ‡­',
            'Korean': 'ğŸ‡°ğŸ‡·'
          };
          return flags[cuisine] || 'ğŸŒ';
        }

        // âœ… Display recipes in UI - Enhanced with cuisine info
        function displayRecipes(recipes) {
          const recipesContainer = document.getElementById('recipesContainer');
          if (recipesContainer) {
            recipesContainer.innerHTML = `
              <h3>ğŸ½ï¸ Diverse Cuisine Recipes for you:</h3>
              <div class="recipes-grid">
                ${recipes.map(recipe => {
                  // Create more specific YouTube search based on detected ingredients
                  let youtubeSearchQuery;
                  
                  if (recipe.youtubeSearch) {
                    // Use custom search term for fallback recipes
                    youtubeSearchQuery = recipe.youtubeSearch;
                  } else {
                    // Use detected ingredients + cuisine for API recipes
                    const detectedIngredients = recipe.usedIngredients ? recipe.usedIngredients.map(ing => ing.name).join(' ') : '';
                    youtubeSearchQuery = detectedIngredients ? 
                      `${detectedIngredients} recipe ${recipe.cuisine || ''}`.trim() : 
                      `${recipe.title} recipe`;
                  }
                  
                  const youtubeSearchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(youtubeSearchQuery)}`;
                  const cuisineFlag = recipe.cuisine ? getCuisineFlag(recipe.cuisine) : 'ğŸŒ';
                  
                  // Debug logging for YouTube search terms
                  console.log(`ğŸ¥ YouTube search for "${recipe.title}": "${youtubeSearchQuery}"`);
                  
                  return `
                    <div class="recipe-card">
                      <div class="recipe-header">
                        <h3>${recipe.title}</h3>
                        <span class="cuisine-badge">${cuisineFlag} ${recipe.cuisine || 'International'}</span>
                      </div>
                      <div class="recipe-meta">
                        <span class="recipe-time">â±ï¸ ${recipe.readyInMinutes || 'N/A'} min</span>
                        <span class="recipe-servings">ğŸ‘¥ ${recipe.servings || 'N/A'} servings</span>
                      </div>
                      <div class="recipe-ingredients">
                        <strong>Made with your ingredients:</strong>
                        <div class="used-ingredients">
                          ${recipe.usedIngredients ? recipe.usedIngredients.map(ing => 
                            `<span class="used-ingredient">${ing.name}</span>`
                          ).join('') : 'All available ingredients!'}
      </div>
      </div>
                      <div class="recipe-links">
                        ${recipe.sourceUrl && recipe.sourceUrl !== '#' ? 
                          `<a href="${recipe.sourceUrl}" target="_blank" class="recipe-link">
                            ğŸ“– View Full Recipe
                          </a>` : 
                          ``
                        }
                        <a href="${youtubeSearchUrl}" target="_blank" class="youtube-link">
                          ğŸ¥ Watch Video Tutorial
                        </a>
      </div>
    </div>
                  `;
                }).join('')}
              </div>
            `;
          }
          
          // Show results
          console.log("ğŸ¯ Hiding loading section and showing results");
          loadingSection.style.display = 'none';
          resultsSection.style.display = 'block';
        }

        // âœ… Event Listeners
        scanBtn.addEventListener('click', startCamera);
        uploadBtn.addEventListener('click', () => uploadBtnMobile.click());
        testBtn.addEventListener('click', testImageProcessing);
        uploadBtnMobile.addEventListener('change', (e) => {
          if (e.target.files[0]) {
            processImage(e.target.files[0]);
          }
        });
        captureBtn.addEventListener('click', capturePhoto);
        closeBtn.addEventListener('click', closeCamera);
        scanAgainBtn.addEventListener('click', () => {
          resultsSection.style.display = 'none';
          loadingSection.style.display = 'none';
        });

        // âœ… Service Worker Registration
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./service-worker.js')
              .then(registration => console.log('SW registered'))
              .catch(error => console.log('SW registration failed:', error));
          });
        }

        // âœ… DOM Content Loaded
        document.addEventListener('DOMContentLoaded', () => {
          console.log("ğŸ½ï¸ CookLook app loaded - Version v3.4-cache-bust");
          console.log("ğŸ¤– AI-powered image recognition with OpenAI Vision API");
          console.log("ğŸ”§ Fallback to color detection if API unavailable");
          
          // Backend API configuration check
          setTimeout(() => {
            console.log("ğŸ”— Backend API Configuration:");
            console.log("- Backend URL:", API_BASE_URL);
            console.log("- Using secure backend for all API calls");
            console.log("- No API keys exposed in frontend");
          }, 1000);
          
          checkHTTPS();
        });
    </script>
</body>
</html>

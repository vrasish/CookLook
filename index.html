<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CookLook | Scan Your Food, Cook a Great Meal</title>
  <link rel="icon" type="image/jpeg" href="IMG_0460.jpg">
  <link rel="apple-touch-icon" href="IMG_0460.jpg">
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#f9b234">
</head>
<body>

  <!-- HERO SECTION -->
  <section class="hero">
    <img src="IMG_0460.jpg" alt="CookLook Logo" class="logo">
    <h1>CookLook</h1>
    <p class="tagline">Scan your food. Cook a great meal.</p>
    <div class="scan-container">
      <button id="scanBtn">üì∏ Scan Your Fridge</button>
      <button id="uploadBtnMobile" class="btn secondary-btn" style="margin-top: 10px;">üìÅ Upload Photo</button>
      <input type="file" id="imageInput" accept="image/*" capture="environment" style="display:none;">
      <img id="preview" style="max-width:90%; margin-top:20px;">
      <p id="mobileNote" style="font-size: 0.9rem; color: #ccc; margin-top: 10px; text-align: center; display: none;">
        üì± <strong>Mobile tip:</strong> If camera doesn't work, use "Upload Photo" instead
      </p>
    </div>
  </section>
  <!-- SCANNING INTERFACE -->
  <section id="scanning" class="scanning-section" style="display: none;">
    <div class="scanning-container">
      <h2>üì∏ Scan Your Ingredients</h2>
      <div class="camera-container">
        <video id="camera" autoplay playsinline></video>
        <canvas id="canvas" style="display: none;"></canvas>
        <div class="camera-overlay">
          <div class="scan-frame"></div>
          <p>Position your ingredients within the frame</p>
        </div>
      </div>
      <div class="camera-controls">
        <button id="captureBtn" class="btn">Capture Photo</button>
        <button id="uploadBtn" class="btn secondary-btn">Upload from Gallery</button>
        <button id="closeCameraBtn" class="btn close-btn">Close Camera</button>
      </div>
    </div>
  </section>

  <!-- LOADING SECTION -->
  <section id="loading" class="loading-section" style="display: none;">
    <div class="loading-container">
      <div class="spinner"></div>
      <h2>Analyzing your ingredients...</h2>
      <p>Our AI is identifying what's in your fridge</p>
    </div>
  </section>

  <!-- RECIPE RESULTS -->
  <section id="results" class="results-section" style="display: none;">
    <div class="results-container">
      <h2>üç≥ Your Custom Recipes</h2>
      <div class="ingredients-detected">
        <h3>Ingredients Found:</h3>
        <div id="ingredientsList" class="ingredients-list"></div>
      </div>
      <div id="recipesContainer" class="recipes-container"></div>
      <button id="scanAgainBtn" class="btn">Scan Again</button>
    </div>
  </section>

  <!-- PROBLEM SECTION -->
  <section id="problem" class="problem">
    <div class="content">
      <h2>Have you ever stared into your fridge...</h2>
      <p>...overflowing with food, and still felt like you had nothing to eat?</p>
      <p class="sub">We solve that common frustration with a creative AI-powered solution!</p>
    </div>
  </section>

  <!-- FEATURES SECTION -->
  <section class="features">
    <h2>Why CookLook?</h2>
    <div class="feature-grid">
      <div class="card">
        <h3>üì∏ Scan Instantly</h3>
        <p>One tap and our app recognizes your ingredients in seconds.</p>
      </div>
      <div class="card">
        <h3>üç≥ Smart Recipes</h3>
        <p>Get fun, simple, and creative dishes from what‚Äôs already in your fridge.</p>
      </div>
      <div class="card">
        <h3>‚ôªÔ∏è Reduce Waste</h3>
        <p>Use up ingredients before they expire and save money effortlessly.</p>
      </div>
    </div>
  </section>

  <!-- SURVEY SECTION -->
  <section class="survey">
    <h2>What Our Customers Say</h2>
    <div class="survey-container">
      <div class="pie">100%<br><span>Yes!</span></div>
      <p>Everyone we surveyed said CookLook makes cooking fun, easy, and stress-free.</p>
    </div>
  </section>

  <!-- QUOTE SECTION -->
  <section class="quote-section">
    <blockquote>
      ‚ÄúOne cannot think well, love well, sleep well, if one has not dined well.‚Äù  
      <span>‚Äì Virginia Woolf</span>
    </blockquote>
  </section>


  <!-- FOOTER -->
  <footer>
    <p>¬© 2025 CookLook | Created by Vaishnavi, James, Kara & Melody</p>
  </footer>
  <script src="config.js"></script>
  <script src="app.js"></script>
  <script>
    // ‚úÖ Service Worker Registration
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js")
        .then(() => console.log("Service Worker registered!"));
    }

    // ‚úÖ API Keys - Load from config
    let HF_API_KEY = "";
    let SPOON_KEY = "d774b10f22674128a2db72604dd1d5ed";
    
    // Load API keys from config file
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const config = await response.json();
        HF_API_KEY = config.HF_API_KEY || "";
        SPOON_KEY = config.SPOON_KEY || SPOON_KEY;
        console.log("‚úÖ Config loaded successfully");
      } catch (err) {
        console.warn("‚ö†Ô∏è Config file not found, using demo mode");
        // No fallback key - will use demo mode instead
      }
    }
    
    // Initialize config
    loadConfig();

    // ‚úÖ Elements
    const scanBtn = document.getElementById("scanBtn");
    const uploadBtnMobile = document.getElementById("uploadBtnMobile");
    const imageInput = document.getElementById("imageInput");
    const preview = document.getElementById("preview");
    const scanningSection = document.getElementById("scanning");
    const camera = document.getElementById("camera");
    const canvas = document.getElementById("canvas");
    const captureBtn = document.getElementById("captureBtn");
    const uploadBtn = document.getElementById("uploadBtn");
    const closeCameraBtn = document.getElementById("closeCameraBtn");
    const loadingSection = document.getElementById("loading");
    const resultsSection = document.getElementById("results");
    const mobileNote = document.getElementById("mobileNote");

    let stream = null;

    // ‚úÖ Scan button - show camera interface
    scanBtn.addEventListener("click", async () => {
      try {
        scanningSection.style.display = "block";
        document.body.style.overflow = "hidden";
        
        // Check if we're on mobile and if camera is available
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
          // For mobile, try different camera constraints
          const constraints = {
            video: {
              facingMode: { ideal: 'environment' },
              width: { ideal: 640, max: 1280 },
              height: { ideal: 480, max: 720 }
            }
          };
          
          // Try to get camera access with mobile-optimized settings
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        } else {
          // For desktop, use higher resolution
          stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
        }
        
        camera.srcObject = stream;
        await camera.play();
        
        // Show success message
        console.log("üì∏ Camera access granted!");
        
      } catch (err) {
        console.error("Camera access error:", err);
        
        let errorMessage = "‚ö†Ô∏è Camera access denied. ";
        
        if (err.name === 'NotAllowedError') {
          errorMessage += "Please allow camera access in your browser settings and try again.";
        } else if (err.name === 'NotFoundError') {
          errorMessage += "No camera found on this device.";
        } else if (err.name === 'NotSupportedError') {
          errorMessage += "Camera not supported. Please use a different browser.";
        } else if (err.name === 'NotReadableError') {
          errorMessage += "Camera is already in use by another application.";
        } else {
          errorMessage += "Error: " + err.message;
        }
        
        alert(errorMessage);
        scanningSection.style.display = "none";
        document.body.style.overflow = "auto";
      }
    });

    // ‚úÖ Capture photo from camera
    captureBtn.addEventListener("click", async () => {
      try {
        const context = canvas.getContext('2d');
        canvas.width = camera.videoWidth;
        canvas.height = camera.videoHeight;
        context.drawImage(camera, 0, 0);
        
        canvas.toBlob(async (blob) => {
          const file = new File([blob], "camera-capture.jpg", { type: "image/jpeg" });
          await processImage(file);
        }, "image/jpeg", 0.8);
        
        // Stop camera and hide scanning section
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
        scanningSection.style.display = "none";
        document.body.style.overflow = "auto";
      } catch (err) {
        console.error("Error capturing photo:", err);
        alert("‚ö†Ô∏è Error capturing photo. Please try again.");
      }
    });

    // ‚úÖ Upload from gallery (camera interface)
    uploadBtn.addEventListener("click", () => imageInput.click());
    
    // ‚úÖ Upload from gallery (mobile fallback)
    uploadBtnMobile.addEventListener("click", () => imageInput.click());

    // ‚úÖ Close camera
    closeCameraBtn.addEventListener("click", () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      scanningSection.style.display = "none";
      document.body.style.overflow = "auto";
    });

    // ‚úÖ File input change
    imageInput.addEventListener("change", async () => {
      const file = imageInput.files[0];
      if (file) {
        await processImage(file);
      } else {
        alert("‚ö†Ô∏è No image selected.");
      }
    });

    // ‚úÖ Process image (camera or file)
    async function processImage(file) {
      try {
        preview.src = URL.createObjectURL(file);
        console.log("üì∏ Image selected:", file.name);
        
        // Show loading
        loadingSection.style.display = "block";
        document.body.style.overflow = "hidden";
        
        await analyzeImage(file);
        
        // Hide loading
        loadingSection.style.display = "none";
        document.body.style.overflow = "auto";
      } catch (err) {
        console.error("Error processing image:", err);
        loadingSection.style.display = "none";
        document.body.style.overflow = "auto";
        alert("‚ö†Ô∏è Error processing image. Please try again.");
      }
    }

    // ‚úÖ Analyze image using a working food model
    async function analyzeImage(file) {
      try {
        // Ensure config is loaded
        await loadConfig();
        
        // Check if API key is set
        if (!HF_API_KEY || HF_API_KEY === "") {
          alert("‚ö†Ô∏è Please set your Hugging Face API key in config.json to use ingredient detection.");
          // Fallback: simulate detection for demo
          const mockIngredients = ["carrot", "onion", "tomato"];
          showDetectedIngredients(mockIngredients);
          await getRecipes(mockIngredients);
          return;
        }

        // Test API key validity
        if (!HF_API_KEY.startsWith('hf_')) {
          alert("‚ö†Ô∏è Invalid API key format. Please check your Hugging Face API key in config.json");
          const mockIngredients = ["carrot", "onion", "tomato"];
          showDetectedIngredients(mockIngredients);
          await getRecipes(mockIngredients);
          return;
        }

        // Convert image to base64 for better compatibility
        const base64Image = await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.readAsDataURL(file);
        });

        // Try multiple food classification models for better detection
        const models = [
          'keremberke/food-image-classification',
          'google/vit-base-patch16-224',
          'facebook/deit-base-patch16-224',
          'microsoft/beit-base-patch16-224'
        ];
        
        let response = null;
        let modelUsed = '';
        
        for (const model of models) {
          try {
            console.log(`üîç Trying model: ${model}`);
            response = await fetch(
              `https://api-inference.huggingface.co/models/${model}`,
              {
                method: "POST",
                headers: {
                  "Authorization": `Bearer ${HF_API_KEY}`,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  inputs: base64Image
                })
              }
            );
            
            if (response.ok) {
              modelUsed = model;
              console.log(`‚úÖ Success with model: ${model}`);
              break;
            } else {
              console.log(`‚ùå Model ${model} failed with status: ${response.status}`);
            }
          } catch (err) {
            console.log(`‚ùå Model ${model} error:`, err);
            continue;
          }
        }
        
        if (!response || !response.ok) {
          throw new Error(`All models failed. Last status: ${response?.status}`);
        }

        if (!response.ok) {
          const errText = await response.text();
          console.error("Model error:", errText);
          
          // Check if response is HTML (error page)
          if (errText.includes('<!doctype html>') || errText.includes('<html')) {
            alert("‚ö†Ô∏è API Error: The model service is temporarily unavailable. Please try again later or use the demo mode.");
            // Fallback to demo mode
            const mockIngredients = ["carrot", "onion", "tomato"];
            showDetectedIngredients(mockIngredients);
            await getRecipes(mockIngredients);
            return;
          }
          
          alert("‚ö†Ô∏è Model error: " + errText.substring(0, 100) + "...");
          return;
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          console.error("Non-JSON response:", await response.text());
          alert("‚ö†Ô∏è API returned unexpected format. Using demo mode.");
          const mockIngredients = ["carrot", "onion", "tomato"];
          showDetectedIngredients(mockIngredients);
          await getRecipes(mockIngredients);
          return;
        }

        const result = await response.json();
        console.log("üçΩÔ∏è AI Result:", result);

        // The model returns label + score (e.g. "carrot": 0.98)
        // Sort by confidence score to prioritize most confident detections
        const sortedResults = result
          .filter(item => item.score > 0.1)  // Lower threshold for better detection
          .sort((a, b) => b.score - a.score);  // Sort by confidence descending

        const ingredients = sortedResults
          .map(item => item.label.toLowerCase())
          .slice(0, 5);  // Get top 5 most confident detections

        console.log("üîç Raw detected ingredients:", ingredients);

        // Enhanced ingredient mapping for better accuracy
        const ingredientMap = {
          // Cruciferous vegetables
          'cauliflower': 'cauliflower',
          'broccoli': 'broccoli',
          'broccoli florets': 'broccoli',
          'broccoli head': 'broccoli',
          'cauliflower florets': 'cauliflower',
          'cauliflower head': 'cauliflower',
          'cabbage': 'cabbage',
          'brussels sprouts': 'brussels sprouts',
          'kale': 'kale',
          'collard greens': 'collard greens',
          'bok choy': 'bok choy',
          'arugula': 'arugula',
          'watercress': 'watercress',
          
          // Root vegetables
          'carrot': 'carrot',
          'potato': 'potato',
          'sweet potato': 'sweet potato',
          'onion': 'onion',
          'garlic': 'garlic',
          'ginger': 'ginger',
          'beet': 'beetroot',
          'beetroot': 'beetroot',
          'radish': 'radish',
          'turnip': 'turnip',
          'parsnip': 'parsnip',
          'rutabaga': 'rutabaga',
          'daikon': 'daikon',
          'horseradish': 'horseradish',
          'turmeric': 'turmeric',
          
          // Leafy greens
          'lettuce': 'lettuce',
          'spinach': 'spinach',
          'arugula': 'arugula',
          'watercress': 'watercress',
          'endive': 'endive',
          'chicory': 'chicory',
          'frisee': 'frisee',
          'mizuna': 'mizuna',
          'tatsoi': 'tatsoi',
          'mustard greens': 'mustard greens',
          'dandelion greens': 'dandelion greens',
          
          // Nightshades
          'tomato': 'tomato',
          'eggplant': 'eggplant',
          'bell pepper': 'bell pepper',
          'pepper': 'bell pepper',
          'chili pepper': 'chili pepper',
          'jalapeno': 'jalapeno',
          'habanero': 'habanero',
          'poblano': 'poblano',
          'anaheim': 'anaheim',
          'serrano': 'serrano',
          'cayenne': 'cayenne',
          'paprika': 'paprika',
          
          // Squash family
          'zucchini': 'zucchini',
          'yellow squash': 'yellow squash',
          'butternut squash': 'butternut squash',
          'acorn squash': 'acorn squash',
          'spaghetti squash': 'spaghetti squash',
          'pumpkin': 'pumpkin',
          'cucumber': 'cucumber',
          'pickle': 'pickle',
          
          // Legumes
          'green beans': 'green beans',
          'beans': 'green beans',
          'snap peas': 'snap peas',
          'snow peas': 'snow peas',
          'peas': 'peas',
          'edamame': 'edamame',
          'lentils': 'lentils',
          'chickpeas': 'chickpeas',
          'black beans': 'black beans',
          'kidney beans': 'kidney beans',
          'pinto beans': 'pinto beans',
          'navy beans': 'navy beans',
          'lima beans': 'lima beans',
          'fava beans': 'fava beans',
          
          // Alliums
          'leek': 'leek',
          'scallion': 'scallion',
          'green onion': 'scallion',
          'shallot': 'shallot',
          'chive': 'chive',
          
          // Mushrooms
          'mushroom': 'mushroom',
          'button mushroom': 'mushroom',
          'cremini': 'cremini',
          'portobello': 'portobello',
          'shiitake': 'shiitake',
          'oyster mushroom': 'oyster mushroom',
          'enoki': 'enoki',
          'maitake': 'maitake',
          'chanterelle': 'chanterelle',
          'morel': 'morel',
          'porcini': 'porcini',
          
          // Herbs
          'basil': 'basil',
          'parsley': 'parsley',
          'cilantro': 'cilantro',
          'dill': 'dill',
          'oregano': 'oregano',
          'thyme': 'thyme',
          'rosemary': 'rosemary',
          'sage': 'sage',
          'mint': 'mint',
          'tarragon': 'tarragon',
          'chives': 'chives',
          'cilantro': 'cilantro',
          'coriander': 'coriander',
          
          // Citrus fruits
          'lemon': 'lemon',
          'lime': 'lime',
          'orange': 'orange',
          'grapefruit': 'grapefruit',
          'tangerine': 'tangerine',
          'mandarin': 'mandarin',
          'clementine': 'clementine',
          'kumquat': 'kumquat',
          'pomelo': 'pomelo',
          
          // Stone fruits
          'peach': 'peach',
          'nectarine': 'nectarine',
          'plum': 'plum',
          'apricot': 'apricot',
          'cherry': 'cherry',
          'mango': 'mango',
          'avocado': 'avocado',
          
          // Berries
          'strawberry': 'strawberry',
          'blueberry': 'blueberry',
          'raspberry': 'raspberry',
          'blackberry': 'blackberry',
          'cranberry': 'cranberry',
          'gooseberry': 'gooseberry',
          'elderberry': 'elderberry',
          'mulberry': 'mulberry',
          'boysenberry': 'boysenberry',
          'loganberry': 'loganberry',
          
          // Tropical fruits
          'pineapple': 'pineapple',
          'banana': 'banana',
          'plantain': 'plantain',
          'coconut': 'coconut',
          'papaya': 'papaya',
          'passion fruit': 'passion fruit',
          'dragon fruit': 'dragon fruit',
          'lychee': 'lychee',
          'rambutan': 'rambutan',
          'durian': 'durian',
          'jackfruit': 'jackfruit',
          'star fruit': 'star fruit',
          'kiwi': 'kiwi',
          
          // Pome fruits
          'apple': 'apple',
          'pear': 'pear',
          'quince': 'quince',
          
          // Melons
          'watermelon': 'watermelon',
          'cantaloupe': 'cantaloupe',
          'honeydew': 'honeydew',
          'crenshaw': 'crenshaw',
          'casaba': 'casaba',
          
          // Other fruits
          'grape': 'grape',
          'fig': 'fig',
          'date': 'date',
          'pomegranate': 'pomegranate',
          'persimmon': 'persimmon',
          'prickly pear': 'prickly pear',
          'cactus pear': 'cactus pear',
          'carrot': 'carrot',
          'onion': 'onion',
          'tomato': 'tomato',
          'potato': 'potato',
          'lettuce': 'lettuce',
          'cabbage': 'cabbage',
          'spinach': 'spinach',
          'cucumber': 'cucumber',
          'pepper': 'bell pepper',
          'bell pepper': 'bell pepper',
          'garlic': 'garlic',
          'ginger': 'ginger',
          'mushroom': 'mushroom',
          'corn': 'corn',
          'peas': 'peas',
          'beans': 'green beans',
          'green beans': 'green beans',
          'celery': 'celery',
          'radish': 'radish',
          'beet': 'beetroot',
          'beetroot': 'beetroot',
          'sweet potato': 'sweet potato',
          'zucchini': 'zucchini',
          'eggplant': 'eggplant',
          'avocado': 'avocado',
          'lemon': 'lemon',
          'lime': 'lime',
          'orange': 'orange',
          'apple': 'apple',
          'banana': 'banana',
          'strawberry': 'strawberry',
          'blueberry': 'blueberry',
          'grape': 'grape',
          'cherry': 'cherry',
          'peach': 'peach',
          'pear': 'pear',
          'pineapple': 'pineapple',
          'mango': 'mango',
          'kiwi': 'kiwi',
          'watermelon': 'watermelon',
          'cantaloupe': 'cantaloupe',
          'honeydew': 'honeydew',
          'pomegranate': 'pomegranate',
          'cranberry': 'cranberry',
          'raspberry': 'raspberry',
          'blackberry': 'blackberry',
          'fig': 'fig',
          'date': 'date',
          'prune': 'prune',
          'raisin': 'raisin',
          'coconut': 'coconut',
          'almond': 'almond',
          'walnut': 'walnut',
          'pecan': 'pecan',
          'cashew': 'cashew',
          'pistachio': 'pistachio',
          'hazelnut': 'hazelnut',
          'macadamia': 'macadamia',
          'brazil nut': 'brazil nut',
          'pine nut': 'pine nut',
          'sunflower seed': 'sunflower seed',
          'pumpkin seed': 'pumpkin seed',
          'sesame seed': 'sesame seed',
          'chia seed': 'chia seed',
          'flax seed': 'flax seed',
          'hemp seed': 'hemp seed',
          'quinoa': 'quinoa',
          'rice': 'rice',
          'wheat': 'wheat',
          'oats': 'oats',
          'barley': 'barley',
          'rye': 'rye',
          'buckwheat': 'buckwheat',
          'millet': 'millet',
          'sorghum': 'sorghum',
          'amaranth': 'amaranth',
          'teff': 'teff',
          'spelt': 'spelt',
          'kamut': 'kamut',
          'farro': 'farro',
          'bulgur': 'bulgur',
          'couscous': 'couscous',
          'pasta': 'pasta',
          'noodle': 'noodle',
          'bread': 'bread',
          'roll': 'roll',
          'bagel': 'bagel',
          'muffin': 'muffin',
          'croissant': 'croissant',
          'donut': 'donut',
          'cake': 'cake',
          'cookie': 'cookie',
          'cracker': 'cracker',
          'chip': 'chip',
          'cereal': 'cereal',
          'granola': 'granola',
          'muesli': 'muesli',
          'yogurt': 'yogurt',
          'cheese': 'cheese',
          'milk': 'milk',
          'cream': 'cream',
          'butter': 'butter',
          'egg': 'egg',
          'meat': 'meat',
          'chicken': 'chicken',
          'beef': 'beef',
          'pork': 'pork',
          'lamb': 'lamb',
          'turkey': 'turkey',
          'duck': 'duck',
          'fish': 'fish',
          'salmon': 'salmon',
          'tuna': 'tuna',
          'cod': 'cod',
          'halibut': 'halibut',
          'mackerel': 'mackerel',
          'sardine': 'sardine',
          'anchovy': 'anchovy',
          'shrimp': 'shrimp',
          'crab': 'crab',
          'lobster': 'lobster',
          'scallop': 'scallop',
          'mussel': 'mussel',
          'clam': 'clam',
          'oyster': 'oyster',
          'squid': 'squid',
          'octopus': 'octopus',
          'tofu': 'tofu',
          'tempeh': 'tempeh',
          'seitan': 'seitan',
          'miso': 'miso',
          'soy sauce': 'soy sauce',
          'tamari': 'tamari',
          'worcestershire sauce': 'worcestershire sauce',
          'hot sauce': 'hot sauce',
          'sriracha': 'sriracha',
          'tabasco': 'tabasco',
          'ketchup': 'ketchup',
          'mustard': 'mustard',
          'mayonnaise': 'mayonnaise',
          'ranch': 'ranch',
          'thousand island': 'thousand island',
          'caesar': 'caesar',
          'italian': 'italian',
          'french': 'french',
          'balsamic': 'balsamic',
          'olive oil': 'olive oil',
          'coconut oil': 'coconut oil',
          'avocado oil': 'avocado oil',
          'sesame oil': 'sesame oil',
          'walnut oil': 'walnut oil',
          'almond oil': 'almond oil',
          'sunflower oil': 'sunflower oil',
          'canola oil': 'canola oil',
          'vegetable oil': 'vegetable oil',
          'corn oil': 'corn oil',
          'peanut oil': 'peanut oil',
          'grapeseed oil': 'grapeseed oil',
          'safflower oil': 'safflower oil',
          'flaxseed oil': 'flaxseed oil',
          'hemp oil': 'hemp oil'
        };

        // Helper function for fuzzy string matching
        function calculateSimilarity(str1, str2) {
          const longer = str1.length > str2.length ? str1 : str2;
          const shorter = str1.length > str2.length ? str2 : str1;
          if (longer.length === 0) return 1.0;
          const editDistance = levenshteinDistance(longer, shorter);
          return (longer.length - editDistance) / longer.length;
        }
        
        function levenshteinDistance(str1, str2) {
          const matrix = [];
          for (let i = 0; i <= str2.length; i++) {
            matrix[i] = [i];
          }
          for (let j = 0; j <= str1.length; j++) {
            matrix[0][j] = j;
          }
          for (let i = 1; i <= str2.length; i++) {
            for (let j = 1; j <= str1.length; j++) {
              if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(
                  matrix[i - 1][j - 1] + 1,
                  matrix[i][j - 1] + 1,
                  matrix[i - 1][j] + 1
                );
              }
            }
          }
          return matrix[str2.length][str1.length];
        }

        // Map detected ingredients to standardized names with better precision
        const mappedIngredients = ingredients
          .map(ingredient => {
            const cleanIngredient = ingredient.toLowerCase().trim();
            
            // First try exact match
            if (ingredientMap[cleanIngredient]) {
              return ingredientMap[cleanIngredient];
            }
            
            // Then try partial match with priority for specific vegetables
            const key = Object.keys(ingredientMap).find(k => {
              // For broccoli and cauliflower, be more specific
              if (cleanIngredient.includes('broccoli') || k.includes('broccoli')) {
                return cleanIngredient.includes('broccoli') && k.includes('broccoli');
              }
              if (cleanIngredient.includes('cauliflower') || k.includes('cauliflower')) {
                return cleanIngredient.includes('cauliflower') && k.includes('cauliflower');
              }
              // For other ingredients, use general matching
              return cleanIngredient.includes(k) || k.includes(cleanIngredient);
            });
            
            if (key) {
              return ingredientMap[key];
            }
            
            // Try fuzzy matching for common variations
            const fuzzyMatches = Object.keys(ingredientMap).filter(k => {
              const similarity = calculateSimilarity(cleanIngredient, k);
              return similarity > 0.7; // 70% similarity threshold
            });
            
            if (fuzzyMatches.length > 0) {
              return ingredientMap[fuzzyMatches[0]];
            }
            
            return cleanIngredient;
          })
          .filter((ingredient, index, arr) => arr.indexOf(ingredient) === index) // Remove duplicates
          .slice(0, 8); // Increased to 8 ingredients

        console.log("üéØ Mapped ingredients:", mappedIngredients);

        if (mappedIngredients.length === 0) {
          // Try fallback detection with a different model
          console.log("No ingredients detected, trying fallback model...");
          try {
            const fallbackResponse = await fetch(
              `https://api-inference.huggingface.co/models/google/vit-base-patch16-224`,
              {
                headers: { Authorization: `Bearer ${HF_API_KEY}` },
                method: "POST",
                body: JSON.stringify({ inputs: base64Data }),
              }
            );
            
            if (fallbackResponse.ok) {
              const fallbackData = await fallbackResponse.json();
              console.log("üîÑ Fallback model response:", fallbackData);
              
              if (Array.isArray(fallbackData) && fallbackData.length > 0) {
                const fallbackIngredients = fallbackData
                  .sort((a, b) => b.score - a.score)
                  .map(item => item.label.toLowerCase())
                  .slice(0, 5);
                
                const fallbackMapped = fallbackIngredients
                  .map(ingredient => {
                    const cleanIngredient = ingredient.toLowerCase().trim();
                    if (ingredientMap[cleanIngredient]) {
                      return ingredientMap[cleanIngredient];
                    }
                    const key = Object.keys(ingredientMap).find(k => 
                      cleanIngredient.includes(k) || k.includes(cleanIngredient)
                    );
                    return key ? ingredientMap[key] : cleanIngredient;
                  })
                  .filter((ingredient, index, arr) => arr.indexOf(ingredient) === index);
                
                if (fallbackMapped.length > 0) {
                  console.log("‚úÖ Fallback ingredients detected:", fallbackMapped);
                  showDetectedIngredients(fallbackMapped);
                  await getRecipes(fallbackMapped);
                  return;
                }
              }
            }
          } catch (fallbackErr) {
            console.log("Fallback model also failed:", fallbackErr);
          }
          
          // Final fallback - use demo mode
          console.log("Using demo mode with common ingredients");
          const mockIngredients = ["carrot", "onion", "tomato", "potato", "bell pepper"];
          showDetectedIngredients(mockIngredients);
          await getRecipes(mockIngredients);
          return;
        }

        // Show detected ingredients in UI
        showDetectedIngredients(mappedIngredients);
        await getRecipes(mappedIngredients);

      } catch (err) {
        console.error("Error analyzing image:", err);
        alert("‚ö†Ô∏è Error analyzing image. Try again later.");
      }
    }

    // ‚úÖ Fetch recipes from Spoonacular
    async function getRecipes(ingredients) {
      try {
        console.log("üîç Searching for recipes with ingredients:", ingredients);
        console.log("üîë Using Spoonacular API key:", SPOON_KEY ? "Present" : "Missing");
        console.log("üîë API key value:", SPOON_KEY);
        
        // Test API key with a simple request first
        if (!SPOON_KEY || SPOON_KEY === "") {
          throw new Error("Spoonacular API key is missing. Please check config.json");
        }
        
        const url = `https://api.spoonacular.com/recipes/findByIngredients?ingredients=${ingredients.join(",")}&number=20&ranking=2&apiKey=${SPOON_KEY}`;
        console.log("üåê API URL:", url);
        
        const res = await fetch(url);
        console.log("üì° API Response status:", res.status, res.statusText);
        
        if (!res.ok) {
          const errorText = await res.text();
          console.error("‚ùå API Error Response:", errorText);
          throw new Error(`API Error ${res.status}: ${errorText}`);
        }
        
        const recipes = await res.json();
        console.log("üìã Raw API response:", recipes);
        console.log("üìä Number of recipes found:", recipes.length);

        console.log("Recipes:", recipes);

        if (!recipes.length) {
          alert("üçΩÔ∏è No recipes found for: " + ingredients.join(", "));
          return;
        }

        // Filter recipes to show those with reasonable missing ingredients
        const filteredRecipes = recipes
          .filter(recipe => {
            // Show recipes with up to 3 missing ingredients (more flexible)
            const missingCount = recipe.missedIngredients ? recipe.missedIngredients.length : 0;
            const usedCount = recipe.usedIngredients ? recipe.usedIngredients.length : 0;
            
            // Prioritize recipes that use more of our ingredients
            // Show if: missing <= 3 AND used >= 2
            return missingCount <= 3 && usedCount >= 2;
          })
          .sort((a, b) => {
            // Sort by: 1) Fewer missing ingredients, 2) More used ingredients
            const aMissing = a.missedIngredients ? a.missedIngredients.length : 0;
            const bMissing = b.missedIngredients ? b.missedIngredients.length : 0;
            const aUsed = a.usedIngredients ? a.usedIngredients.length : 0;
            const bUsed = b.usedIngredients ? b.usedIngredients.length : 0;
            
            if (aMissing !== bMissing) {
              return aMissing - bMissing; // Fewer missing first
            }
            return bUsed - aUsed; // More used first
          })
          .slice(0, 5); // Show top 5 recipes

        if (filteredRecipes.length === 0) {
          console.log("‚ö†Ô∏è No filtered recipes found, trying individual ingredient searches...");
          
          // Try searching with individual ingredients as fallback
          const individualSearches = [];
          for (const ingredient of ingredients) {
            try {
              const individualUrl = `https://api.spoonacular.com/recipes/findByIngredients?ingredients=${ingredient}&number=5&ranking=2&apiKey=${SPOON_KEY}`;
              console.log(`üîç Individual search for: ${ingredient}`);
              
              const individualRes = await fetch(individualUrl);
              console.log(`üì° Individual response status for ${ingredient}:`, individualRes.status);
              
              if (!individualRes.ok) {
                console.log(`‚ùå Individual search failed for ${ingredient}: ${individualRes.status}`);
                continue;
              }
              
              const individualRecipes = await individualRes.json();
              
              if (individualRecipes && individualRecipes.length > 0) {
                individualSearches.push(...individualRecipes);
                console.log(`‚úÖ Found ${individualRecipes.length} recipes for ${ingredient}`);
              } else {
                console.log(`‚ö†Ô∏è No recipes found for ${ingredient}`);
              }
            } catch (err) {
              console.log(`‚ùå Individual search error for ${ingredient}:`, err);
            }
          }
          
          if (individualSearches.length > 0) {
            // Remove duplicates and show individual results
            const uniqueRecipes = individualSearches.filter((recipe, index, self) => 
              index === self.findIndex(r => r.id === recipe.id)
            );
            
            console.log("üîÑ Using individual search results:", uniqueRecipes.length);
            displayRecipes(uniqueRecipes.slice(0, 3));
            return;
          }
          
          alert("üçΩÔ∏è No recipes found that can be made with your available ingredients. Try adding more ingredients to your fridge!");
          return;
        }

        // Display recipes in UI
        displayRecipes(filteredRecipes);
      } catch (err) {
        console.error("‚ùå Error fetching recipes:", err);
        
        // Check if it's an API key issue
        if (err.message.includes('401') || err.message.includes('Unauthorized')) {
          alert("üîë API key issue. Please check your Spoonacular API key in config.json");
        } else if (err.message.includes('429') || err.message.includes('quota')) {
          alert("‚è∞ API quota exceeded. Please try again later or check your API limits.");
        } else if (err.message.includes('NetworkError') || err.message.includes('Failed to fetch')) {
          alert("üåê Network error. Please check your internet connection and try again.");
        } else {
          alert(`‚ö†Ô∏è Error fetching recipes: ${err.message}\n\nPlease check the console for more details.`);
        }
      }
    }

    // ‚úÖ Show detected ingredients in UI
    function showDetectedIngredients(ingredients) {
      const ingredientsList = document.getElementById('ingredientsList');
      if (ingredientsList) {
        ingredientsList.innerHTML = ingredients.map(ingredient => 
          `<span class="ingredient-tag">${ingredient}</span>`
        ).join('');
      }
    }

    // ‚úÖ Display recipes in UI with YouTube videos
    function displayRecipes(ingredients, recipes) {
      const resultsSection = document.getElementById('results');
      const recipesContainer = document.getElementById('recipesContainer');
      
      if (resultsSection && recipesContainer) {
        // Show results section
        resultsSection.style.display = 'block';
        
        // Create recipe cards with YouTube videos
        recipesContainer.innerHTML = recipes.map((recipe, index) => {
          // Generate YouTube search URL for recipe videos
          const youtubeSearchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(recipe.title + ' recipe cooking tutorial')}`;
          
          return `
            <div class="recipe-card">
              <h3>${recipe.title}</h3>
              <div class="recipe-meta">
                <span class="recipe-time">‚è±Ô∏è ${recipe.readyInMinutes || 'N/A'} min</span>
                <span class="recipe-servings">üë• ${recipe.servings || 'N/A'} servings</span>
              </div>
              <div class="recipe-ingredients">
                <strong>Made with your ingredients:</strong>
                <div class="used-ingredients">
                  ${recipe.usedIngredients ? recipe.usedIngredients.map(ing => 
                    `<span class="used-ingredient">${ing.name}</span>`
                  ).join('') : 'All available ingredients!'}
                </div>
              </div>
              <div class="recipe-links">
                <a href="${recipe.sourceUrl || '#'}" target="_blank" class="recipe-link">
                  üìñ View Full Recipe
                </a>
                <a href="${youtubeSearchUrl}" target="_blank" class="youtube-link">
                  üé• Watch Video Tutorial
                </a>
              </div>
            </div>
          `;
        }).join('');
        
        // Scroll to results
        resultsSection.scrollIntoView({ behavior: 'smooth' });
      }
    }

    // ‚úÖ Check if running on HTTPS (required for camera on mobile)
    function checkHTTPS() {
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        console.warn("‚ö†Ô∏è Camera access requires HTTPS on mobile devices");
        return false;
      }
      return true;
    }

    // ‚úÖ Initialize app with mobile considerations
    document.addEventListener('DOMContentLoaded', () => {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      if (isMobile) {
        console.log("üì± Mobile device detected");
        
        // Check HTTPS requirement
        if (!checkHTTPS()) {
          console.warn("‚ö†Ô∏è For camera access on mobile, please use HTTPS");
          mobileNote.style.display = "block";
        } else {
          // Show mobile tip
          mobileNote.style.display = "block";
        }
      }
    });
  </script>
  </body>
  </html>
